(function(){"use strict";class n{static SIZE=4;static NEW_CELL_VALUE_TWO_PROBABILITY=.9;_score;_grid;constructor(e){e?(this._grid=e.grid.map(r=>r.slice()),this._score=e.score):(this._grid=this.initializeGrid(),this._score=0,this.addRandomTile(),this.addRandomTile())}clone(){return new n({grid:this._grid.map(e=>e.slice()),score:this._score})}getGreatesPieceValue(){let e=0;for(let r=0;r<n.SIZE;r++)for(let s=0;s<n.SIZE;s++)this.grid[r][s]>e&&(e=this.grid[r][s]);return e}addRandomTile(){const e=[];for(let r=0;r<n.SIZE;r++)for(let s=0;s<n.SIZE;s++)this.grid[r][s]===0&&e.push([r,s]);if(e.length>0){const r=Math.floor(Math.random()*e.length),[s,t]=e[r];return this.grid[s][t]=Math.random()<n.NEW_CELL_VALUE_TWO_PROBABILITY?2:4,{x:t,y:s}}}print(){console.log(`--- SCORE: ${this.score} ---`);for(let e=0;e<n.SIZE;e++)console.log(e+":	"+this.grid[e].join("	"));console.log(`

`)}get score(){return this._score}get grid(){return this._grid}gameIsOver(){for(let e=0;e<this.grid.length;e++)for(let r=0;r<this.grid[e].length;r++)if(this.grid[e][r]===0)return!1;for(let e=0;e<this.grid.length;e++)for(let r=0;r<this.grid[e].length;r++){const s=this.grid[e][r];if(r<this.grid[e].length-1&&s===this.grid[e][r+1]||e<this.grid.length-1&&s===this.grid[e+1][r])return!1}return!0}initializeGrid(){const e=[];for(let r=0;r<n.SIZE;r++){e[r]=[];for(let s=0;s<n.SIZE;s++)e[r][s]=0}return e}}var c=(d=>(d[d.Up=0]="Up",d[d.Down=1]="Down",d[d.Left=2]="Left",d[d.Right=3]="Right",d))(c||{});const u=Object.keys(c).filter(d=>!isNaN(Number(d))).map(d=>Number(d));class g{board;constructor(e){this.board=e.clone()}canMove(e){switch(e){case c.Left:return this.canMoveInDirection(-1,0);case c.Right:return this.canMoveInDirection(1,0);case c.Up:return this.canMoveInDirection(0,-1);case c.Down:return this.canMoveInDirection(0,1);default:return!1}}move(e){if(!this.canMove(e))return{board:this.board,translations:[]};switch(e){case c.Left:return this.moveLeft();case c.Right:return this.moveRight();case c.Up:return this.moveUp();case c.Down:return this.moveDown()}}transposeGrid(e){const r=Array.from({length:n.SIZE},()=>Array(n.SIZE).fill(0));for(let s=0;s<n.SIZE;s++)for(let t=0;t<n.SIZE;t++)r[t][s]=e[s][t];return r}reverseColumns(e){return[...e].reverse()}transformTranslations(e,r){return e.map(s=>{let t={...s.from},o={...s.to};switch(r){case c.Down:t.y=n.SIZE-1-t.y,o.y=n.SIZE-1-o.y;break;case c.Left:[t.x,t.y]=[t.y,t.x],[o.x,o.y]=[o.y,o.x];break;case c.Right:t.y=n.SIZE-1-t.y,o.y=n.SIZE-1-o.y,[t.x,t.y]=[t.y,t.x],[o.x,o.y]=[o.y,o.x];break}return{from:t,to:o}})}canMoveInDirection(e,r){for(let s=0;s<n.SIZE;s++)for(let t=0;t<n.SIZE;t++){const o=this.board.grid[s][t];if(o!==0){const i=s+r,a=t+e;if(i>=0&&i<n.SIZE&&a>=0&&a<n.SIZE&&(this.board.grid[i][a]===0||this.board.grid[i][a]===o))return!0}}return!1}mergeColumnUp(e){const r=[],s=new Set;let t=0;for(let o=0;o<e.length;o++)if(e[o]!==0){const i=e[o],a=r[r.length-1],l=r.length-1;a===i&&!s.has(l)?(r[r.length-1]*=2,s.add(l),t+=r[r.length-1]):r.push(i)}return{mergedTiles:r,score:t}}generateTranslationsForColumn(e,r){const s=[],t=[],o=new Set;for(let i=0;i<e.length;i++)if(e[i]!==0){const a=e[i],l=t[t.length-1],f=t.length-1;l===a&&!o.has(f)?(o.add(f),s.push({from:{y:i,x:r},to:{y:f,x:r}})):(t.push(a),s.push({from:{y:i,x:r},to:{y:t.length-1,x:r}}))}return s}moveUp(){const e=[];let r=0;const s=Array.from({length:n.SIZE},()=>Array(n.SIZE).fill(0));for(let i=0;i<n.SIZE;i++){const a=this.board.grid.map(h=>h[i]),{mergedTiles:l,score:f}=this.mergeColumnUp(a),m=this.generateTranslationsForColumn(a,i);r+=f,e.push(...m);for(let h=0;h<l.length;h++)s[h][i]=l[h]}const t=new n({grid:s,score:this.board.score+r}),o=t.addRandomTile();return{board:t,translations:e,created:o}}moveDown(){const e=this.reverseColumns(this.board.grid),r=new n({grid:e,score:this.board.score}),t=new g(r).moveUp(),o=this.reverseColumns(t.board.grid),i=new n({grid:o,score:t.board.score}),a=this.transformTranslations(t.translations,c.Down);return{board:i,translations:a,created:t.created?{x:t.created.x,y:n.SIZE-1-t.created.y}:void 0}}moveLeft(){const e=this.transposeGrid(this.board.grid),r=new n({grid:e,score:this.board.score}),t=new g(r).moveUp(),o=this.transposeGrid(t.board.grid),i=new n({grid:o,score:t.board.score}),a=this.transformTranslations(t.translations,c.Left);return{board:i,translations:a,created:t.created?{x:t.created.y,y:t.created.x}:void 0}}moveRight(){const e=this.transposeGrid(this.board.grid),r=this.reverseColumns(e),s=new n({grid:r,score:this.board.score}),o=new g(s).moveUp(),i=this.reverseColumns(o.board.grid),a=this.transposeGrid(i),l=new n({grid:a,score:o.board.score}),f=this.transformTranslations(o.translations,c.Right);let m;if(o.created){const h=n.SIZE-1-o.created.y,p=o.created.x;m={x:h,y:p}}return{board:l,translations:f,created:m}}}class v{runs;constructor(e=1e3){this.runs=e}findBestMove(e){const r=new Map;u.filter(t=>new g(e).canMove(t)).forEach(t=>{const o=new g(e).move(t);for(let i=0;i<this.runs;i++){const a=this.randomlyPlayUntilItsOver(o.board);r.has(t)?r.get(t).push(a):r.set(t,[a])}});let s={direction:c.Down,avg:-1};return r.forEach((t,o)=>{const i=t.reduce((a,l)=>a+l,0)/t.length;(i>s.avg||s.avg===-1)&&(s.direction=o,s.avg=i)}),s.direction}randomlyPlayUntilItsOver(e){let r=e;for(;!r.gameIsOver();){const s=new g(r),t=u.filter(i=>s.canMove(i));if(t.length===0){console.log("no move available");break}const o=t[Math.floor(Math.random()*t.length)];r=s.move(o).board}return r.score}}postMessage({ready:!0}),self.onmessage=d=>{const e=d.data;try{const r=new v(e.runs),s=new n({grid:JSON.parse(e.grid),score:-1}),t={direction:r.findBestMove(s.clone()),messageId:e.messageId};self.postMessage(t)}catch(r){console.log(`WW ${e} got exception`),console.error(r),self.postMessage(r)}}})();
