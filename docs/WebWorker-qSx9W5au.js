(function(){"use strict";class i{static SIZE=4;static NEW_CELL_VALUE_TWO_PROBABILITY=.9;_score;_grid;constructor(t){t?(this._grid=t.grid.map(r=>r.slice()),this._score=t.score):(this._grid=this.initializeGrid(),this._score=0,this.addRandomTile(),this.addRandomTile())}clone(){return new i({grid:this._grid.map(t=>t.slice()),score:this._score})}getGreatesPieceValue(){let t=0;for(let r=0;r<i.SIZE;r++)for(let o=0;o<i.SIZE;o++)this.grid[r][o]>t&&(t=this.grid[r][o]);return t}addRandomTile(){const t=[];for(let r=0;r<i.SIZE;r++)for(let o=0;o<i.SIZE;o++)this.grid[r][o]===0&&t.push([r,o]);if(t.length>0){const r=Math.floor(Math.random()*t.length),[o,l]=t[r];return this.grid[o][l]=Math.random()<i.NEW_CELL_VALUE_TWO_PROBABILITY?2:4,{x:l,y:o}}}print(){console.log(`--- SCORE: ${this.score} ---`);for(let t=0;t<i.SIZE;t++)console.log(t+":	"+this.grid[t].join("	"));console.log(`

`)}get score(){return this._score}get grid(){return this._grid}gameIsOver(){for(let t=0;t<this.grid.length;t++)for(let r=0;r<this.grid[t].length;r++)if(this.grid[t][r]===0)return!1;for(let t=0;t<this.grid.length;t++)for(let r=0;r<this.grid[t].length;r++){const o=this.grid[t][r];if(r<this.grid[t].length-1&&o===this.grid[t][r+1]||t<this.grid.length-1&&o===this.grid[t+1][r])return!1}return!0}initializeGrid(){const t=[];for(let r=0;r<i.SIZE;r++){t[r]=[];for(let o=0;o<i.SIZE;o++)t[r][o]=0}return t}}var g=(c=>(c[c.Up=0]="Up",c[c.Down=1]="Down",c[c.Left=2]="Left",c[c.Right=3]="Right",c))(g||{});const m=Object.keys(g).filter(c=>!isNaN(Number(c))).map(c=>Number(c));class f{board;constructor(t){this.board=t.clone()}canMove(t){switch(t){case g.Left:return this.canMoveInDirection(-1,0);case g.Right:return this.canMoveInDirection(1,0);case g.Up:return this.canMoveInDirection(0,-1);case g.Down:return this.canMoveInDirection(0,1);default:return!1}}move(t){if(!this.canMove(t))return{board:this.board,translations:[]};switch(t){case g.Left:return this.moveLeft();case g.Right:return this.moveRight();case g.Up:return this.moveUp();case g.Down:return this.moveDown()}}canMoveInDirection(t,r){for(let o=0;o<i.SIZE;o++)for(let l=0;l<i.SIZE;l++){const h=this.board.grid[o][l];if(h!==0){const n=o+r,a=l+t;if(n>=0&&n<i.SIZE&&a>=0&&a<i.SIZE&&(this.board.grid[n][a]===0||this.board.grid[n][a]===h))return!0}}return!1}moveUp(){const t=[];let r=0;const o=Array.from({length:i.SIZE},()=>Array(i.SIZE).fill(0));for(let n=0;n<i.SIZE;n++){const a=this.board.grid.map(e=>e[n]),s=[];for(let e=0;e<a.length;e++)if(a[e]!==0){const d=a[e];s[s.length-1]===d?(s[s.length-1]*=2,a[e]=0,r+=s[s.length-1]):(a[e]=0,s.push(d)),t.push({from:{y:e,x:n},to:{y:s.length-1,x:n}})}for(let e=0;e<s.length;e++)o[e][n]=s[e];for(let e=s.length;e<i.SIZE;e++)o[e][n]=0}const l=new i({grid:o,score:this.board.score+r}),h=l.addRandomTile();return{board:l,translations:t,created:h}}moveDown(){const t=[];let r=0;const o=Array.from({length:i.SIZE},()=>Array(i.SIZE).fill(0));for(let n=0;n<i.SIZE;n++){const a=this.board.grid.map(e=>e[n]),s=[];for(let e=a.length-1;e>=0;e--)if(a[e]!==0){const d=a[e];s[s.length-1]===d?(s[s.length-1]*=2,a[e]=0,r+=s[s.length-1]):(a[e]=0,s.push(d)),t.push({from:{y:e,x:n},to:{y:i.SIZE-1-(s.length-1),x:n}})}for(let e=i.SIZE-1;e>=i.SIZE-s.length;e--)o[e][n]=s[i.SIZE-1-e];for(let e=i.SIZE-1-s.length;e>=0;e--)o[e][n]=0}const l=new i({grid:o,score:this.board.score+r}),h=l.addRandomTile();return{board:l,translations:t,created:h}}moveLeft(){const t=[];let r=0;const o=Array.from({length:i.SIZE},()=>Array(i.SIZE).fill(0));for(let n=0;n<i.SIZE;n++){const a=this.board.grid[n],s=[];for(let e=0;e<a.length;e++)if(a[e]!==0){const d=a[e];s[s.length-1]===d?(s[s.length-1]*=2,a[e]=0,r+=s[s.length-1]):(a[e]=0,s.push(d)),t.push({from:{y:n,x:e},to:{y:n,x:s.length-1}})}for(let e=0;e<s.length;e++)o[n][e]=s[e];for(let e=s.length;e<i.SIZE;e++)o[n][e]=0}const l=new i({grid:o,score:this.board.score+r}),h=l.addRandomTile();return{board:l,translations:t,created:h}}moveRight(){const t=[];let r=0;const o=Array.from({length:i.SIZE},()=>Array(i.SIZE).fill(0));for(let n=0;n<i.SIZE;n++){const a=this.board.grid[n],s=[];for(let e=a.length-1;e>=0;e--)if(a[e]!==0){const d=a[e];s[s.length-1]===d?(s[s.length-1]*=2,a[e]=0,r+=s[s.length-1]):(a[e]=0,s.push(d)),t.push({from:{y:n,x:e},to:{y:n,x:i.SIZE-1-(s.length-1)}})}for(let e=i.SIZE-1;e>=i.SIZE-s.length;e--)o[n][e]=s[i.SIZE-1-e];for(let e=i.SIZE-1-s.length;e>=0;e--)o[n][e]=0}const l=new i({grid:o,score:this.board.score+r}),h=l.addRandomTile();return{board:l,translations:t,created:h}}}class I{runs;constructor(t=1e3){this.runs=t}findBestMove(t){const r=new Map;m.filter(l=>new f(t).canMove(l)).forEach(l=>{const h=new f(t).move(l);for(let n=0;n<this.runs;n++){const a=this.randomlyPlayUntilItsOver(h.board);r.has(l)?r.get(l).push(a):r.set(l,[a])}});let o={direction:g.Down,avg:-1};return r.forEach((l,h)=>{const n=l.reduce((a,s)=>a+s,0)/l.length;(n>o.avg||o.avg===-1)&&(o.direction=h,o.avg=n)}),o.direction}randomlyPlayUntilItsOver(t){let r=t;for(;!r.gameIsOver();){const o=new f(r),l=m.filter(n=>o.canMove(n));if(l.length===0){console.log("no move available");break}const h=l[Math.floor(Math.random()*l.length)];r=o.move(h).board}return r.score}}postMessage({ready:!0}),self.onmessage=c=>{const t=c.data;try{const r=new I(t.runs),o=new i({grid:JSON.parse(t.grid),score:-1}),l={direction:r.findBestMove(o.clone()),messageId:t.messageId};self.postMessage(l)}catch(r){console.log(`WW ${t} got exception`),console.error(r),self.postMessage(r)}}})();
